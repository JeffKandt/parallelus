#!/usr/bin/env bash
set -euo pipefail

repo_root=$(git rev-parse --show-toplevel 2>/dev/null || exit 0)
cd "$repo_root"
# shellcheck source=../bin/agents-doc-paths.sh
. "$repo_root/parallelus/engine/bin/agents-doc-paths.sh"

if [[ -n "${AGENTS_MERGE_FORCE:-}" ]]; then
  echo "pre-merge-commit: AGENTS_MERGE_FORCE set; skipping enforcement." >&2
  exit 0
fi

shopt -s nullglob
plan_files=("docs/branches/"*/PLAN.md)
progress_files=("docs/branches/"*/PROGRESS.md)
shopt -u nullglob

if ((${#plan_files[@]} > 0)); then
  echo "pre-merge-commit: branch plan notebooks still present:" >&2
  for f in "${plan_files[@]}"; do
    echo "  - $f" >&2
  done
  echo "Fold plan updates into the canonical plan and remove branch notebooks (or override via AGENTS_MERGE_FORCE=1)." >&2
  exit 1
fi

if ((${#progress_files[@]} > 0)); then
  echo "pre-merge-commit: branch progress notebooks still present:" >&2
  for f in "${progress_files[@]}"; do
    echo "  - $f" >&2
  done
  echo "Stitch progress entries into the canonical log and remove branch notebooks (or override via AGENTS_MERGE_FORCE=1)." >&2
  exit 1
fi

if [[ -z "${AGENTS_MERGE_SKIP_HOOK_CI:-}" ]]; then
  if ! make ci >/dev/null; then
    echo "pre-merge-commit: make ci failed; resolve issues before merging." >&2
    echo "(Override with AGENTS_MERGE_FORCE=1 git merge --no-ff ... if absolutely necessary.)" >&2
    exit 1
  fi
fi

merge_branch="${AGENTS_MERGE_BRANCH:-}"
if [[ -z "$merge_branch" && -f .git/MERGE_MSG ]]; then
  merge_branch=$(sed -nE "s/^Merge branch '([^']+)'/\1/p" .git/MERGE_MSG | head -n1)
fi
slugged_branch="${merge_branch//\//-}"

resolved_review_file() {
  local branch="$1"
  local file="$2"
  if [[ -n "$file" ]]; then
    printf '%s' "$file"
    return
  fi
  if [[ -n "$branch" ]]; then
    python3 - "$branch" <<'PY'
import sys
from pathlib import Path

branch = sys.argv[1]
base = branch.replace('/', '-')
candidates = []
for reviews_dir in [Path('docs/parallelus/reviews')]:
    if not reviews_dir.exists():
        continue
    direct = reviews_dir / f"{base}.md"
    if direct.exists():
        print(direct)
        sys.exit(0)
    for path in reviews_dir.glob(f"{base}-*.md"):
        try:
            candidates.append((path.stat().st_mtime, path))
        except FileNotFoundError:
            continue

if candidates:
    candidates.sort(reverse=True)
    print(candidates[0][1])
PY
    return
  fi
  local staged=()
  mapfile -t staged < <(git diff --cached --name-only -- 'docs/parallelus/reviews/*.md')
  if [[ ${#staged[@]} -eq 1 ]]; then
    printf '%s' "${staged[0]}"
    return
  fi
  printf ''
}

review_file=$(resolved_review_file "$merge_branch" "${AGENTS_MERGE_REVIEW_FILE:-}")

if [[ -z "$review_file" || ! -f "$review_file" ]]; then
  echo "pre-merge-commit: senior architect review missing." >&2
  echo "Expected docs/parallelus/reviews/<branch>.md with Decision: approved." >&2
  echo "Set AGENTS_MERGE_REVIEW_FILE=/path/to/review.md or AGENTS_MERGE_FORCE=1 to override." >&2
  exit 1
fi

if [[ -n "$merge_branch" ]]; then
  if ! grep -qi "^Reviewed-Branch:\s*$merge_branch" "$review_file"; then
    echo "pre-merge-commit: review $review_file does not reference branch $merge_branch." >&2
    echo "Update the review or override via AGENTS_MERGE_FORCE=1." >&2
    exit 1
  fi
fi

if ! grep -qi '^Decision:\s*approved' "$review_file"; then
  echo "pre-merge-commit: review $review_file is not marked Decision: approved." >&2
  echo "Resolve review feedback or override via AGENTS_MERGE_FORCE=1." >&2
  exit 1
fi

review_commit=$(grep -i '^Reviewed-Commit:' "$review_file" | head -n1 | sed -E 's/Reviewed-Commit:[[:space:]]*//I')
review_commit=${review_commit// /}
if [[ -z "$review_commit" ]]; then
  echo "pre-merge-commit: review $review_file must include Reviewed-Commit: <hash>." >&2
  echo "Add the commit hash or override via AGENTS_MERGE_FORCE=1." >&2
  exit 1
fi

expected_commit="${AGENTS_MERGE_COMMIT:-}"
if [[ -z "$expected_commit" && -n "$merge_branch" ]]; then
  expected_commit=$(git rev-parse "$merge_branch" 2>/dev/null || true)
fi

if [[ -n "$expected_commit" && "$review_commit" != "$expected_commit" ]]; then
  if git merge-base --is-ancestor "$review_commit" "$expected_commit" 2>/dev/null; then
    diff_names=$(git diff --name-only "$review_commit" "$expected_commit")
    allow_doc_only=1
    while IFS= read -r path; do
      [[ -z "$path" ]] && continue
      case "$path" in
        docs/guardrails/runs/*|docs/parallelus/reviews/*|docs/PLAN.md|docs/PROGRESS.md|docs/branches/*|parallelus/manuals/*|docs/parallelus/self-improvement/markers/*|docs/parallelus/self-improvement/reports/*|.parallelus/sessions/*)
          ;;
        *)
          allow_doc_only=0
          break
          ;;
      esac
    done <<<"$diff_names"
    if (( allow_doc_only == 1 )); then
      echo "pre-merge-commit: doc-only follow-up commits detected; proceeding with approved review $review_commit." >&2
    else
      echo "pre-merge-commit: additional commits after $review_commit modify non-doc files." >&2
      echo "Re-review the final commit or override via AGENTS_MERGE_FORCE=1." >&2
      exit 1
    fi
  else
    echo "pre-merge-commit: review $review_file covers $review_commit but merge input is $expected_commit (non-ancestor)." >&2
    echo "Re-review the final commit or override via AGENTS_MERGE_FORCE=1." >&2
    exit 1
  fi
fi

if grep -Eqi 'Severity:\s*(Blocker|High)' "$review_file"; then
  echo "pre-merge-commit: high/blocker findings remain in $review_file." >&2
  echo "Address outstanding issues or override via AGENTS_MERGE_FORCE=1." >&2
  exit 1
fi

pending_ack=$(grep -Ei 'Severity:\s*(Medium|Low|Info)' "$review_file" || true)
if [[ -n "$pending_ack" ]]; then
  if [[ -z "${AGENTS_MERGE_ACK_REVIEW:-}" ]]; then
    echo "pre-merge-commit: review $review_file notes additional findings:" >&2
    echo "$pending_ack" >&2
    echo "Document resolutions or re-run with AGENTS_MERGE_ACK_REVIEW=1 to proceed." >&2
    exit 1
  else
    echo "pre-merge-commit: AGENTS_MERGE_ACK_REVIEW acknowledged remaining findings." >&2
  fi
fi

review_date=$(grep -i '^Reviewed-On:' "$review_file" || true)
if [[ -z "$review_date" ]]; then
  echo "pre-merge-commit: review $review_file must include Reviewed-On: <date>." >&2
  echo "Add the field or override via AGENTS_MERGE_FORCE=1." >&2
  exit 1
fi

check_retrospective() {
  local marker_path="${AGENTS_RETRO_MARKER:-}"
  local report_path="${AGENTS_RETRO_REPORT:-}"
  if [[ -n "$marker_path" && -n "$report_path" && -f "$marker_path" && -f "$report_path" ]]; then
    return
  fi
  if [[ -z "$slugged_branch" ]]; then
    echo "pre-merge-commit: unable to infer branch slug for retrospective check." >&2
    exit 1
  fi
  marker_path="$(parallelus_marker_read_path "$repo_root" "$slugged_branch")"
  if [[ ! -f "$marker_path" ]]; then
    marker_path="$(parallelus_marker_write_path "$repo_root" "$slugged_branch")"
  fi
  if [[ ! -f "$marker_path" ]]; then
    echo "pre-merge-commit: run make turn_end to record a retrospective marker before merging." >&2
    exit 1
  fi
  local reports_dir
  reports_dir="$(dirname "$(dirname "$marker_path")")/reports"
  local status=0
  report_path=$(
    python3 - "$marker_path" "$merge_branch" "$reports_dir" <<'PY'
import json
import sys
from pathlib import Path

marker_path = Path(sys.argv[1])
branch = sys.argv[2]
reports_dir = Path(sys.argv[3])

try:
    marker = json.loads(marker_path.read_text())
except Exception as exc:
    print(f"pre-merge-commit: unable to parse {marker_path}: {exc}", file=sys.stderr)
    sys.exit(2)

marker_ts = marker.get("timestamp")
if not marker_ts:
    print(f"pre-merge-commit: marker {marker_path} missing timestamp", file=sys.stderr)
    sys.exit(3)

if not reports_dir.exists():
    print("pre-merge-commit: retrospective reports directory missing", file=sys.stderr)
    sys.exit(4)

for path in sorted(reports_dir.glob('*.json')):
    try:
        data = json.loads(path.read_text())
    except Exception:
        continue
    if data.get("branch") == branch and data.get("marker_timestamp") == marker_ts:
        print(path)
        sys.exit(0)

print(f"pre-merge-commit: no retrospective report found for marker {marker_ts}", file=sys.stderr)
sys.exit(5)
PY
  ) || status=$?
  if [[ ${status:-0} -ne 0 || -z "$report_path" ]]; then
    exit 1
  fi
}

check_retrospective
exit 0
