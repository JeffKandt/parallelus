#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../agentrc
. "${SCRIPT_DIR}/../agentrc"

repo_root=$(git rev-parse --show-toplevel 2>/dev/null || true)
if [[ -z "$repo_root" ]]; then
  echo "agents-detect: not inside a git repository" >&2
  exit 1
fi

cd "$repo_root"

current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "detached")
sanitized_branch=${current_branch//\//-}
expected_plan="$PLAN_DIR/${sanitized_branch}.md"
expected_progress="$PROGRESS_DIR/${sanitized_branch}.md"
remote_list="$(git remote)"

has_remote=false
if [[ -n "$remote_list" ]]; then
  has_remote=true
fi

base_branch=""
if [[ "$has_remote" == true ]]; then
  if git symbolic-ref --quiet "refs/remotes/${BASE_REMOTE}/HEAD" >/dev/null; then
    remote_head=$(git symbolic-ref --quiet "refs/remotes/${BASE_REMOTE}/HEAD" || true)
    base_branch=${remote_head#refs/remotes/${BASE_REMOTE}/}
  fi
fi

if [[ -z "$base_branch" ]]; then
  if git show-ref --verify --quiet refs/heads/"${DEFAULT_BASE}"; then
    base_branch="$DEFAULT_BASE"
  elif git show-ref --verify --quiet refs/heads/main; then
    base_branch="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    base_branch="master"
  else
    base_branch="$current_branch"
  fi
fi

repo_mode="detached"
if [[ "$has_remote" == true ]]; then
  repo_mode="remote-connected"
fi

declare -a remote_unmerged=()
declare -a local_unmerged=()
if [[ "$repo_mode" == "remote-connected" ]]; then
  remote_base_ref="refs/remotes/${BASE_REMOTE}/$base_branch"
  if git show-ref --verify --quiet "$remote_base_ref"; then
    while IFS= read -r ref; do
      [[ -z "$ref" || "$ref" == "${BASE_REMOTE}/$base_branch" || "$ref" == "${BASE_REMOTE}/HEAD" ]] && continue
      [[ "$ref" =~ ^${BASE_REMOTE}/archive/ ]] && continue
      remote_unmerged+=("$ref")
    done < <(git for-each-ref --format='%(refname:strip=2)' "refs/remotes/${BASE_REMOTE}" --no-merged="$remote_base_ref" || true)
  fi

  while IFS= read -r branch; do
    [[ -z "$branch" || "$branch" == "$base_branch" || "$branch" == "$current_branch" ]] && continue
    [[ "$branch" =~ ^archive/ ]] && continue
    local_unmerged+=("$branch")
  done < <(git branch --no-merged "$base_branch" 2>/dev/null | sed 's/^[ *]*//' || true)
fi

join_by_comma() {
  local IFS=','
  printf '%s' "$*"
}

remote_csv="$(join_by_comma "${remote_unmerged[@]-}")"
local_csv="$(join_by_comma "${local_unmerged[@]-}")"

# Detect orphaned notebooks
shopt -s nullglob
declare -a orphan_paths=()
for path in "$PLAN_DIR"/*.md "$PROGRESS_DIR"/*.md; do
  [[ $(basename "$path") == "README.md" ]] && continue
  if [[ "$path" == "$expected_plan" || "$path" == "$expected_progress" ]]; then
    continue
  fi
  orphan_paths+=("$path")
done
shopt -u nullglob
orphan_csv="$(join_by_comma "${orphan_paths[@]-}")"

printf 'REPO_MODE=%s\n' "$repo_mode"
printf 'BASE_BRANCH=%s\n' "$base_branch"
printf 'CURRENT_BRANCH=%s\n' "$current_branch"
printf 'BASE_REMOTE=%s\n' "$BASE_REMOTE"
printf 'HAS_REMOTE=%s\n' "$has_remote"
printf 'UNMERGED_REMOTE=%s\n' "$remote_csv"
printf 'UNMERGED_LOCAL=%s\n' "$local_csv"
printf 'ORPHANED_NOTEBOOKS=%s\n' "$orphan_csv"
printf 'ARCHIVE_NAMESPACE=%s\n' "$ARCHIVE_NAMESPACE"
printf 'PROJECT_NAME=%s\n' "$PROJECT_NAME"

if [[ -n "$remote_csv" || -n "$local_csv" ]]; then
  {
    echo
    echo "[agents-detect] Branches pending merge/archive relative to $base_branch:" 
    if [[ -n "$remote_csv" ]]; then
      printf '  Remote: %s\n' "$remote_csv"
    fi
    if [[ -n "$local_csv" ]]; then
      printf '  Local: %s\n' "$local_csv"
    fi
    echo "[agents-detect] Options: merge the work, archive it, or prune stale refs."
  } >&2
fi

if [[ -n "$orphan_csv" ]]; then
  {
    echo
    echo "[agents-detect] WARNING: Orphaned plan/progress notebooks detected"
    IFS=',' read -r -a arr <<< "$orphan_csv"
    for item in "${arr[@]}"; do
      [[ -z "$item" ]] && continue
      printf '  - %s\n' "$item"
    done
    echo "[agents-detect] Fold branch docs into canonical logs before merging."
  } >&2
fi
